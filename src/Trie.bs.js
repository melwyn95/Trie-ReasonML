// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var compare = Caml_obj.caml_compare;

var ChildrenMap = $$Map.Make(/* module */[/* compare */compare]);

var dummy_node = /* record */[
  /* value : " " */32,
  /* isWord */false,
  /* children */ChildrenMap[/* empty */0]
];

function Make($star) {
  var root = /* record */[
    /* value : " " */32,
    /* isWord */false,
    /* children */ChildrenMap[/* empty */0]
  ];
  var addWord = function (_root, word, _index) {
    while(true) {
      var index = _index;
      var root = _root;
      if (index === word.length) {
        return /* () */0;
      } else {
        var childNode;
        try {
          childNode = Curry._2(ChildrenMap[/* find */21], Caml_string.get(word, index), root[/* children */2]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            var newNode = /* record */[
              /* value */Caml_string.get(word, index),
              /* isWord */false,
              /* children */ChildrenMap[/* empty */0]
            ];
            root[/* children */2] = Curry._3(ChildrenMap[/* add */3], Caml_string.get(word, index), newNode, root[/* children */2]);
            childNode = newNode;
          } else {
            throw exn;
          }
        }
        if (index === (word.length - 1 | 0)) {
          childNode[/* isWord */1] = true;
        }
        _index = index + 1 | 0;
        _root = childNode;
        continue ;
      }
    };
  };
  var findWord = function (_root, word, _index) {
    while(true) {
      var index = _index;
      var root = _root;
      if (index === word.length && root[/* isWord */1]) {
        return true;
      } else if (index === word.length) {
        return false;
      } else {
        var childNode;
        try {
          childNode = Curry._2(ChildrenMap[/* find */21], Caml_string.get(word, index), root[/* children */2]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            childNode = dummy_node;
          } else {
            throw exn;
          }
        }
        if (childNode[/* value */0] === /* " " */32) {
          return false;
        } else {
          _index = index + 1 | 0;
          _root = childNode;
          continue ;
        }
      }
    };
  };
  var listAllWords = function (root, lst, str) {
    var retLst = /* record */[/* contents */lst];
    if (root[/* isWord */1]) {
      retLst[0] = List.append(lst, /* :: */[
            str,
            /* [] */0
          ]);
    }
    Curry._2(ChildrenMap[/* iter */9], (function (ch, node) {
            retLst[0] = listAllWords(node, retLst[0], str + $$String.make(1, ch));
            return /* () */0;
          }), root[/* children */2]);
    return retLst[0];
  };
  var deleteWord = function (_root, word, _index) {
    while(true) {
      var index = _index;
      var root = _root;
      if (index === word.length) {
        return /* () */0;
      } else {
        var childNode;
        try {
          childNode = Curry._2(ChildrenMap[/* find */21], Caml_string.get(word, index), root[/* children */2]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            childNode = dummy_node;
          } else {
            throw exn;
          }
        }
        if (childNode[/* isWord */1] && index === (word.length - 1 | 0)) {
          childNode[/* isWord */1] = false;
          if (Curry._1(ChildrenMap[/* cardinal */15], childNode[/* children */2]) === 0) {
            root[/* children */2] = Curry._2(ChildrenMap[/* remove */5], Caml_string.get(word, index), root[/* children */2]);
            return /* () */0;
          } else {
            return 0;
          }
        } else {
          _index = index + 1 | 0;
          _root = childNode;
          continue ;
        }
      }
    };
  };
  var findPrefixRoot = function (_root, str, _index) {
    while(true) {
      var index = _index;
      var root = _root;
      console.log(str, String(index));
      if (index === str.length) {
        return root;
      } else {
        var childNode;
        try {
          childNode = Curry._2(ChildrenMap[/* find */21], Caml_string.get(str, index), root[/* children */2]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            childNode = dummy_node;
          } else {
            throw exn;
          }
        }
        if (childNode[/* value */0] === /* " " */32) {
          return undefined;
        } else if (index === (str.length - 1 | 0)) {
          return childNode;
        } else {
          _index = index + 1 | 0;
          _root = childNode;
          continue ;
        }
      }
    };
  };
  var listWords = function (root, str) {
    var optionRoot = findPrefixRoot(root, str, 0);
    if (optionRoot !== undefined) {
      return listAllWords(optionRoot, /* [] */0, str);
    } else {
      return /* [] */0;
    }
  };
  return /* module */[
          /* root */root,
          /* addWord */addWord,
          /* findWord */findWord,
          /* deleteWord */deleteWord,
          /* listAllWords */listAllWords,
          /* listWords */listWords
        ];
}

exports.ChildrenMap = ChildrenMap;
exports.dummy_node = dummy_node;
exports.Make = Make;
/* ChildrenMap Not a pure module */
